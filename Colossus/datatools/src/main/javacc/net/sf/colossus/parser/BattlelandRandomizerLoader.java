/* Generated By:JavaCC: Do not edit this line. BattlelandRandomizerLoader.java */
package net.sf.colossus.parser;


import java.util.ArrayList;
import java.util.Collections;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

import net.sf.colossus.variant.BattleHex;
import net.sf.colossus.variant.HazardHexside;
import net.sf.colossus.variant.HazardTerrain;


/**
 * BattlelandRandomizerLoader create a randomized Battleland from a description file.
 * @author Romain Dolbeau
 * @version $Id: BattlelandRandomizerLoader.jj 3995 2009-04-08 14:11:43Z cleka $
 * @see net.sf.colossus.variant.BattleHex
 */
@SuppressWarnings("all")
public class BattlelandRandomizerLoader implements
    BattlelandRandomizerLoaderConstants
{
    private static final boolean[][] show = {
        { false, false, true, true, true, false },
        { false, true, true, true, true, false },
        { false, true, true, true, true, true },
        { true, true, true, true, true, true },
        { false, true, true, true, true, true },
        { false, true, true, true, true, false } };
    private static final Random rand = new net.sf.colossus.util.DevRandom();

    private List<address> leftover;
    private List<address> usedup;

    BattleHex[][] hexes;

    private String title = "Randomized!";
    private String subtitle = "Randomized!";

    public String getTitle()
    {
        return title;
    }

    public String getSubtitle()
    {
        return subtitle;
    }

    Hashtable<String, List<address>> labels = new Hashtable<String, List<address>>();

    /* code executed just before the constructor call */
    /* used to add the predefined labels to the Hashtable */
    {
        int i, j;
        List<address> al;

        al = new ArrayList<address>();

        for (i = 1; i <= 4; i++)
            for (j = 2; j <= 3; j++)
                al.add(new address(i, j));
        al.add(new address(3, 1));
        for (i = 2; i <= 4; i++)
            al.add(new address(i, 4));
        labels.put("inside", al);

        al = new ArrayList<address>();

        for (i = 2; i <= 4; i++)
            al.add(new address(0, i));
        labels.put("leftdefenseentry", al);

        al = new ArrayList<address>();

        al.add(new address(3, 0));
        for (i = 4; i <= 5; i++)
            al.add(new address(i, 1));
        labels.put("upperdefenseentry", al);

        al = new ArrayList<address>();

        al.add(new address(5, 4));
        for (i = 3; i <= 4; i++)
            al.add(new address(i, 5));
        labels.put("lowerdefenseentry", al);

        al = new ArrayList<address>();

        for (i = 0; i < 6; i++)
            for (j = 0; j < 6; j++)
                if (show[i][j])
                    al.add(new address(i, j));
        labels.put("anywhere", al);
    }

    private class randomHazard implements Comparable<randomHazard>
    {
        private final String terrain;
        private final double prob;
        private final double[] e_prob = new double[3];

        private double percent(double val)
        {
            if (val < 0.)
                return 0.;
            if (val > 100.)
                return 100.;
            return val;
        }

        private double percent(double val, double sum)
        {
            return ((val * 100.) / sum);
        }

        randomHazard(String t)
        {
            terrain = t;
            prob = 100.;
            e_prob[0] = 100.;
            e_prob[1] = 0.;
            e_prob[2] = 0.;
        }

        randomHazard(String t, double p, int e)
        {
            terrain = t;
            prob = percent(p);
            e_prob[0] = 0.;
            e_prob[1] = 0.;
            e_prob[2] = 0.;
            if ((e < 1) || (e > 2))
                e_prob[0] = 100.;
            else
                e_prob[e] = 100.;
        }

        randomHazard(String t, double p, double p1, double p2, double p3)
        {
            double sum = percent(p1) + percent(p2) + percent(p3);
            terrain = t;
            prob = percent(p);
            e_prob[0] = percent(p1, sum);
            e_prob[1] = percent(p2, sum);
            e_prob[2] = percent(p3, sum);
        }

        @Override
        public String toString()
        {
            String s = "Hazard '" + terrain + "'";
            if (prob < 100.)
                s = s + " (" + prob + "%)";
            s = s + " [" + e_prob[0] + "/" + e_prob[1] + "/" + e_prob[2] + "]";
            return s;
        }

        public int compareTo(randomHazard other)
        {
            if (other.prob != prob)
            {
                return (prob > other.prob ? -1 : 1);
            }
            return 0;
        }
    }

    private class address implements Comparable<address>
    {
        final int x;
        final int y;

        address(int ox, int oy)
        {
            x = ox;
            y = oy;
        }

        @Override
        public String toString()
        {
            return "(" + x + "," + y + ")";
        }

        public String toCaseLabel()
        {
            char xc = 'X';
            char yc = 'X';
            switch (x)
            {
                case 0:
                    xc = 'A';
                    yc = Integer.toString(5 - y).charAt(0);
                    break;
                case 1:
                    xc = 'B';
                    yc = Integer.toString(5 - y).charAt(0);
                    break;
                case 2:
                    xc = 'C';
                    yc = Integer.toString(6 - y).charAt(0);
                    break;
                case 3:
                    xc = 'D';
                    yc = Integer.toString(6 - y).charAt(0);
                    break;
                case 4:
                    xc = 'E';
                    yc = Integer.toString(6 - y).charAt(0);
                    break;
                case 5:
                    xc = 'F';
                    yc = Integer.toString(5 - y).charAt(0);
                    break;
            }
            return (xc + "" + yc);
        }

        public int compareTo(address other)
        {
            if (other.x != x)
            {
                return (x < other.x ? -1 : 1);
            }
            if (other.y != y)
            {
                return (y < other.y ? -1 : 1);
            }
            return 0;
        }

        @Override
        public boolean equals(Object o)
        {
            if (o == null)
                return false;
            if (!(o instanceof address))
                return false;
            address ot = (address)o;
            return ((x == ot.x) && (y == ot.y));
        }
    }

    private boolean exist(address a)
    {
        return (a.x >= 0) && (a.x < show.length) && (a.y >= 0)
            && (a.y < show[0].length) && (show[a.x][a.y]);
    }

    private class range
    {
        final int min;
        final int max;

        range(int mi, int ma)
        {
            min = mi;
            max = ma;
        }
    }

    private void resolveOne(BattleHex[][] h, List<address> al, randomHazard t)
    {
        if (al.isEmpty())
            return;
        double result = rand.nextDouble() * 100.;
        if (result >= t.prob)
            return;
        int pos = rand.nextInt(al.size());
        address a = al.remove(pos);
        BattleHex hex = h[a.x][a.y];
        hex.setTerrain(HazardTerrain.getTerrainByName(t.terrain));
        result = rand.nextDouble() * 100.;
        hex.setElevation(0);
        if (result > t.e_prob[0])
            hex.setElevation(1);
        if (result > (t.e_prob[0] + t.e_prob[1]))
            hex.setElevation(2);
        usedup.add(a);
    }

    private void resolveAll(BattleHex[][] h, List<address> al,
        List<randomHazard> tl)
    {
        usedup = new ArrayList<address>();
        Iterator<randomHazard> it = tl.iterator();
        while (it.hasNext())
        {
            randomHazard rt = it.next();
            resolveOne(h, al, rt);
        }
        leftover = al;
    }

    private final Map<hazardPair, List<randomHexside>> hexsideRandomness = new TreeMap<hazardPair, List<randomHexside>>();

    private class hazardPair implements Comparable<Object>
    {
        final String hs;
        final int es;
        final String hd;
        final int ed;

        private hazardPair(String hs, int es, String hd, int ed)
        {
            this.hs = hs;
            this.es = es;
            this.hd = hd;
            this.ed = ed;
        }

        @Override
        public boolean equals(Object o)
        {
            if (o == null)
                return false;
            if (!(o instanceof hazardPair))
                return false;
            hazardPair h = (hazardPair)o;
            return ((hs == h.hs) && (hd == h.hd) && (es == h.es) && (ed == h.ed));
        }

        public int compareTo(Object o)
        {
            hazardPair h = (hazardPair)o;
            if ((hs == h.hs) && (hd == h.hd) && (es == h.es) && (ed == h.ed))
                return 0;
            if (!hs.equals(h.hs))
                return (hs.compareTo(h.hs));
            if (!hd.equals(h.hd))
                return (hd.compareTo(h.hd));
            if (es != h.es)
                return (es < h.es ? -1 : 1);
            if (ed != h.ed)
                return (ed < h.ed ? -1 : 1);
            return 0;
        }

        @Override
        public String toString()
        {
            return ("Pair: " + hs + "/" + (es == -1 ? "*" : "" + es) + " to "
                + hd + "/" + (ed == -1 ? "*" : "" + ed));
        }
    }

    private class randomHexside
    {
        private final HazardHexside hazard;
        private final double prob;

        private double percent(double val)
        {
            if (val < 0.)
                return 0.;
            if (val > 100.)
                return 100.;
            return val;
        }

        @SuppressWarnings("deprecation")
        randomHexside(char hChar, double p)
        {
            HazardHexside hObj = HazardHexside.getHexsideByCode(hChar);
            hazard = hObj;
            prob = percent(p);
        }

        HazardHexside getHexsideHazard()
        {
            return hazard;
        }

        double getProb()
        {
            return prob;
        }

        @Override
        public String toString()
        {
            return ("HexsideHazard " + hazard + " " + (prob < 100. ? prob
                + " %" : ""));
        }
    }

    private List<randomHexside> findHazardPairBestMatch(hazardPair p)
    {
        hazardPair p2;
        List<randomHexside> al;
        p2 = p;
        al = hexsideRandomness.get(p2);
        if (al != null) // exact match
            return al;
        p2 = new hazardPair(p.hs, p.es, p.hd, -1);
        al = hexsideRandomness.get(p2);
        if (al != null)
            return al;
        p2 = new hazardPair(p.hs, -1, p.hd, p.ed);
        al = hexsideRandomness.get(p2);
        if (al != null)
            return al;
        p2 = new hazardPair(p.hs, -1, p.hd, -1);
        al = hexsideRandomness.get(p2);
        if (al != null)
            return al;
        return null;
    }

    public void resolveAllHexsides(BattleHex h[][])
    {
        for (int i = 0; i < 6; i++)
        {
            for (int j = 0; j < 6; j++)
            {
                if (show[i][j])
                {
                    for (int k = 0; k < 6; k++)
                    {
                        BattleHex hd = h[i][j].getNeighbor(k);
                        if (hd != null)
                        {
                            String ts = h[i][j].getTerrain().getName();
                            int es = h[i][j].getElevation();
                            String td = hd.getTerrain().getName();
                            int ed = hd.getElevation();
                            hazardPair hp = new hazardPair(ts, es, td, ed);
                            List<randomHexside> hsl = findHazardPairBestMatch(hp);
                            if (hsl != null)
                            {
                                boolean attributed = false;
                                Iterator<randomHexside> it = hsl.iterator();
                                while (!attributed && it.hasNext())
                                {
                                    randomHexside rhs = it.next();
                                    if ((rand.nextDouble() * 100.) < rhs
                                        .getProb())
                                    {
                                        attributed = true;
                                        h[i][j].setHexsideHazard(k, rhs
                                            .getHexsideHazard());
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (startlistAddress != null)
        {
            startlist = new java.util.ArrayList<String>();
            java.util.Iterator<address> it = startlistAddress.iterator();
            while (it.hasNext())
            {
                address ad = it.next();
                startlist.add(ad.toCaseLabel());
            }
        }
    }

    /** hold the list of label for the startlist */
    private java.util.List<String> startlist = null;

    /** hold the list of address prior resolution for the startlist */
    private java.util.List<address> startlistAddress = null;

    /** is the terrain a Tower ? */
    private boolean isTower = false;

    public java.util.List<String> getStartList()
    {
        return startlist;
    }

    public boolean isTower()
    {
        return isTower;
    }

    final public String z_comment() throws ParseException
    {
        jj_consume_token(COMMENT);
        {
            if (true)
                return (new String(token.image));
        }
        throw new Error("Missing return statement in function");
    }

    final public char z_terrain() throws ParseException
    {
        jj_consume_token(HAZARD);
        {
            if (true)
                return (token.image.charAt(0));
        }
        throw new Error("Missing return statement in function");
    }

    final public String z_label() throws ParseException
    {
        jj_consume_token(CHAINE);
        {
            if (true)
                return new String(token.image);
        }
        throw new Error("Missing return statement in function");
    }

    final public int z_number() throws ParseException
    {
        if (jj_2_1(20))
        {
            jj_consume_token(NUMBER);
            {
                if (true)
                    return (Integer.parseInt(token.image));
            }
        }
        else if (jj_2_2(20))
        {
            jj_consume_token(STAR);
            {
                if (true)
                    return (-1);
            }
        }
        else
        {
            jj_consume_token(-1);
            throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public double z_fpnumber() throws ParseException
    {
        if (jj_2_3(20))
        {
            jj_consume_token(FPNUMBER);
            {
                if (true)
                    return (Double.parseDouble(token.image));
            }
        }
        else if (jj_2_4(20))
        {
            jj_consume_token(STAR);
            {
                if (true)
                    return (-1);
            }
        }
        else
        {
            jj_consume_token(-1);
            throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public String z_chaine() throws ParseException
    {
        if (jj_2_5(20))
        {
            jj_consume_token(CHAINE);
            {
                if (true)
                    return (new String(token.image));
            }
        }
        else if (jj_2_6(20))
        {
            jj_consume_token(QUOTEDCHAINE);
            String tok = new String(token.image);
            String cha = tok.substring(1, tok.length() - 1);
            {
                if (true)
                    return (cha);
            }
        }
        else
        {
            jj_consume_token(-1);
            throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public address z_address() throws ParseException
    {
        int x, y;
        if (jj_2_7(20))
        {
            jj_consume_token(OPENPAR);
            x = z_number();
            jj_consume_token(COMMA);
            y = z_number();
            jj_consume_token(CLOSEPAR);
            {
                if (true)
                    return new address(x, y);
            }
        }
        else if (jj_2_8(20))
        {
            jj_consume_token(CASELABEL);
            switch (token.image.charAt(0))
            {
                case 'A':
                case 'a':
                    x = 0;
                    break;
                case 'B':
                case 'b':
                    x = 1;
                    break;
                case 'C':
                case 'c':
                    x = 2;
                    break;
                case 'D':
                case 'd':
                    x = 3;
                    break;
                case 'E':
                case 'e':
                    x = 4;
                    break;
                case 'F':
                case 'f':
                    x = 5;
                    break;
                default:
                {
                    if (true)
                        throw new ParseException("Hex " + token.image
                            + "doesn't exist");
                }
            }
            y = 6 - Integer.parseInt(new String(token.image.substring(1)));
            y = y - Math.abs(((x - 3) / 2));
            {
                if (true)
                    return new address(x, y);
            }
        }
        else
        {
            jj_consume_token(-1);
            throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public range z_range() throws ParseException
    {
        int a, b;
        a = z_number();
        jj_consume_token(CARET);
        b = z_number();
        {
            if (true)
                return new range(a, b);
        }
        throw new Error("Missing return statement in function");
    }

    final public List<address> z_listAddress() throws ParseException
    {
        address ad;
        List<address> al, al2, al3;
        int x, y;
        range r1, r2;
        int i, j;
        String s;
        if (jj_2_9(20))
        {
            jj_consume_token(SOMEOF);
            jj_consume_token(OPENPAR);
            x = z_number();
            jj_consume_token(COMMA);
            al2 = z_listAddress();
            jj_consume_token(CLOSEPAR);
            al = z_listAddress();
            List<address> al4 = new ArrayList<address>(al);
            while (!al2.isEmpty() && (x > 0))
            {
                ad = al2.remove(rand.nextInt(al2.size()));
                al4.add(ad);
                x--;
            }
            {
                if (true)
                    return al4;
            }
        }
        else if (jj_2_10(20))
        {
            jj_consume_token(SUBSTRACT);
            jj_consume_token(OPENPAR);
            al3 = z_listAddress();
            jj_consume_token(COMMA);
            al2 = z_listAddress();
            jj_consume_token(CLOSEPAR);
            al = z_listAddress();
            List<address> al4 = new ArrayList<address>(al);
            Iterator<address> it = al3.iterator();
            while (it.hasNext())
            {
                ad = it.next();
                if (!(al2.contains(ad)))
                {
                    al4.add(ad);
                }
            }
            {
                if (true)
                    return al4;
            }
        }
        else if (jj_2_11(20))
        {
            jj_consume_token(OPENPAR);
            jj_consume_token(LEFTOVER);
            jj_consume_token(CLOSEPAR);
            al = z_listAddress();
            List<address> al4 = new ArrayList<address>(al);
            if (leftover != null)
            {
                Iterator<address> it = leftover.iterator();
                while (it.hasNext())
                    al4.add(it.next());
            }
            {
                if (true)
                    return al4;
            }
        }
        else if (jj_2_12(20))
        {
            jj_consume_token(SURROUNDINGSOF);
            jj_consume_token(OPENPAR);
            al2 = z_listAddress();
            jj_consume_token(CLOSEPAR);
            al = z_listAddress();
            List<address> al4 = new ArrayList<address>(al);
            if (al2 != null)
            {
                Set<address> tempSet = new TreeSet<address>();
                Iterator<address> it = al2.iterator();
                while (it.hasNext())
                {
                    ad = it.next();
                    for (i = 0; i < 6; i++)
                    {
                        BattleHex hex = hexes[ad.x][ad.y].getNeighbor(i);
                        if (hex != null)
                        {
                            tempSet.add(new address(hex.getXCoord(), hex
                                .getYCoord()));
                        }
                    }
                }
                it = al2.iterator();
                while (it.hasNext())
                {
                    ad = it.next();
                    tempSet.remove(ad);
                }
                it = tempSet.iterator();
                while (it.hasNext())
                {
                    ad = it.next();
                    al4.add(ad);
                }
            }
            {
                if (true)
                    return al4;
            }
        }
        else if (jj_2_13(20))
        {
            jj_consume_token(OPENPAR);
            jj_consume_token(USEDUP);
            jj_consume_token(CLOSEPAR);
            al = z_listAddress();
            List<address> al4 = new ArrayList<address>(al);
            if (usedup != null)
            {
                Iterator<address> it = usedup.iterator();
                while (it.hasNext())
                    al4.add(it.next());
            }
            {
                if (true)
                    return al4;
            }
        }
        else if (jj_2_14(20))
        {
            jj_consume_token(OPENPAR);
            s = z_label();
            jj_consume_token(CLOSEPAR);
            al = z_listAddress();
            List<address> al4 = new ArrayList<address>(al);
            List<address> ll = labels.get(s);
            if (ll != null)
            {
                Iterator<address> it = ll.iterator();
                while (it.hasNext())
                    al4.add(it.next());
            }
            {
                if (true)
                    return al4;
            }
        }
        else if (jj_2_15(20))
        {
            ad = z_address();
            al = z_listAddress();
            if (exist(ad))
                al.add(ad);
            {
                if (true)
                    return (al);
            }
        }
        else if (jj_2_16(20))
        {
            jj_consume_token(OPENPAR);
            r1 = z_range();
            jj_consume_token(COMMA);
            y = z_number();
            jj_consume_token(CLOSEPAR);
            al = z_listAddress();
            for (i = r1.min; i <= r1.max; i++)
            {
                ad = new address(i, y);
                if (exist(ad))
                    al.add(ad);
            }
            {
                if (true)
                    return al;
            }
        }
        else if (jj_2_17(20))
        {
            jj_consume_token(OPENPAR);
            x = z_number();
            jj_consume_token(COMMA);
            r2 = z_range();
            jj_consume_token(CLOSEPAR);
            al = z_listAddress();
            for (i = r2.min; i <= r2.max; i++)
            {
                ad = new address(x, i);
                if (exist(ad))
                    al.add(ad);
            }
            {
                if (true)
                    return al;
            }
        }
        else if (jj_2_18(20))
        {
            jj_consume_token(OPENPAR);
            r1 = z_range();
            jj_consume_token(COMMA);
            r2 = z_range();
            jj_consume_token(CLOSEPAR);
            al = z_listAddress();
            for (i = r1.min; i <= r1.max; i++)
                for (j = r2.min; j <= r2.max; j++)
                {
                    ad = new address(i, j);
                    if (exist(ad))
                        al.add(ad);
                }
            {
                if (true)
                    return al;
            }
        }
        else
        {
            {
                if (true)
                    return new ArrayList<address>();
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public List<randomHazard> z_listHazard() throws ParseException
    {
        String t;
        int e = 0;
        List<randomHazard> tl;
        double p = 100.0, p1, p2, p3;
        if (jj_2_22(20))
        {
            t = z_chaine();
            if (jj_2_19(20))
            {
                jj_consume_token(COMMA);
                p = z_fpnumber();
            }
            else
            {
                // auto generated - ignore
            }
            jj_consume_token(COMMA);
            p1 = z_fpnumber();
            jj_consume_token(COMMA);
            p2 = z_fpnumber();
            jj_consume_token(COMMA);
            p3 = z_fpnumber();
            tl = z_listHazard();
            randomHazard rt = new randomHazard(t, p, p1, p2, p3);
            tl.add(rt);
            {
                if (true)
                    return tl;
            }
        }
        else if (jj_2_23(20))
        {
            t = z_chaine();
            if (jj_2_20(20))
            {
                jj_consume_token(COMMA);
                p = z_fpnumber();
            }
            else
            {
                // auto generated - ignore
            }
            if (jj_2_21(20))
            {
                jj_consume_token(COMMA);
                e = z_number();
            }
            else
            {
                // auto generated - ignore
            }
            tl = z_listHazard();
            randomHazard rt = new randomHazard(t, p, e);
            tl.add(rt);
            {
                if (true)
                    return tl;
            }
        }
        else
        {
            {
                if (true)
                    return new ArrayList<randomHazard>();
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public List<randomHexside> z_listHexside() throws ParseException
    {
        char t;
        List<randomHexside> hl;
        double p = 100.0;
        if (jj_2_25(20))
        {
            t = z_terrain();
            if (jj_2_24(20))
            {
                jj_consume_token(COMMA);
                p = z_fpnumber();
            }
            else
            {
                // auto generated - ignore
            }
            hl = z_listHexside();
            randomHexside rh = new randomHexside(t, p);
            hl.add(rh);
            {
                if (true)
                    return hl;
            }
        }
        else
        {
            {
                if (true)
                    return new ArrayList<randomHexside>();
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public hazardPair z_hazardPair() throws ParseException
    {
        String ts, td;
        int es, ed;
        jj_consume_token(OPENPAR);
        ts = z_chaine();
        jj_consume_token(COMMA);
        es = z_number();
        jj_consume_token(CLOSEPAR);
        jj_consume_token(OPENPAR);
        td = z_chaine();
        jj_consume_token(COMMA);
        ed = z_number();
        jj_consume_token(CLOSEPAR);
        {
            if (true)
                return new hazardPair(ts, es, td, ed);
        }
        throw new Error("Missing return statement in function");
    }

    final public int oneArea(BattleHex h[][]) throws ParseException
    {
        List<address> al;
        List<randomHazard> tl;
        List<randomHexside> tl2;
        String s;
        hexes = h;
        hazardPair hp;
        if (jj_2_26(20))
        {
            jj_consume_token(AREA);
            al = z_listAddress();
            jj_consume_token(HAZARDS);
            tl = z_listHazard();
            Collections.sort(al);
            Collections.reverse(tl);
            //System.err.println("Using area: " + al + ", terrains: " + tl);
            resolveAll(h, al, tl);
            //System.err.println("Usedup: " + usedup);
            //System.err.println("Leftover: " + leftover);
            {
                if (true)
                    return (1);
            }
        }
        else if (jj_2_27(20))
        {
            jj_consume_token(KEYLABEL);
            s = z_label();
            jj_consume_token(EQUAL);
            al = z_listAddress();
            labels.put(s, al);
            {
                if (true)
                    return (0);
            }
        }
        else if (jj_2_28(20))
        {
            jj_consume_token(KEYTITLE);
            s = z_chaine();
            title = s;
            {
                if (true)
                    return (0);
            }
        }
        else if (jj_2_29(20))
        {
            jj_consume_token(KEYSUBTITLE);
            s = z_chaine();
            subtitle = s;
            {
                if (true)
                    return (0);
            }
        }
        else if (jj_2_30(20))
        {
            jj_consume_token(PAIR);
            hp = z_hazardPair();
            jj_consume_token(HEXSIDES);
            tl2 = z_listHexside();
            //System.out.println("For " + hp + " we'll use " + tl2);
            Collections.reverse(tl2);
            hexsideRandomness.put(hp, tl2);
            //System.out.println("NOW: " + hexsideRandomness);
            {
                if (true)
                    return (0);
            }
        }
        else if (jj_2_31(20))
        {
            jj_consume_token(TOWER);
            isTower = true;
            {
                if (true)
                    return 0;
            }
        }
        else if (jj_2_32(20))
        {
            jj_consume_token(STARTLIST);
            al = z_listAddress();
            startlistAddress = new java.util.ArrayList<address>(al);
            {
                if (true)
                    return 0;
            }
        }
        else if (jj_2_33(20))
        {
            jj_consume_token(EOL);
            {
                if (true)
                    return (0);
            }
        }
        else if (jj_2_34(20))
        {
            s = z_comment();
            {
                if (true)
                    return (0);
            }
        }
        else if (jj_2_35(20))
        {
            jj_consume_token(0);
            {
                if (true)
                    return (-1);
            }
        }
        else
        {
            jj_consume_token(-1);
            throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    private boolean jj_2_1(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_1();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(0, xla);
        }
    }

    private boolean jj_2_2(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_2();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(1, xla);
        }
    }

    private boolean jj_2_3(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_3();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(2, xla);
        }
    }

    private boolean jj_2_4(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_4();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(3, xla);
        }
    }

    private boolean jj_2_5(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_5();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(4, xla);
        }
    }

    private boolean jj_2_6(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_6();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(5, xla);
        }
    }

    private boolean jj_2_7(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_7();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(6, xla);
        }
    }

    private boolean jj_2_8(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_8();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(7, xla);
        }
    }

    private boolean jj_2_9(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_9();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(8, xla);
        }
    }

    private boolean jj_2_10(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_10();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(9, xla);
        }
    }

    private boolean jj_2_11(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_11();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(10, xla);
        }
    }

    private boolean jj_2_12(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_12();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(11, xla);
        }
    }

    private boolean jj_2_13(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_13();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(12, xla);
        }
    }

    private boolean jj_2_14(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_14();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(13, xla);
        }
    }

    private boolean jj_2_15(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_15();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(14, xla);
        }
    }

    private boolean jj_2_16(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_16();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(15, xla);
        }
    }

    private boolean jj_2_17(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_17();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(16, xla);
        }
    }

    private boolean jj_2_18(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_18();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(17, xla);
        }
    }

    private boolean jj_2_19(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_19();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(18, xla);
        }
    }

    private boolean jj_2_20(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_20();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(19, xla);
        }
    }

    private boolean jj_2_21(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_21();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(20, xla);
        }
    }

    private boolean jj_2_22(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_22();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(21, xla);
        }
    }

    private boolean jj_2_23(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_23();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(22, xla);
        }
    }

    private boolean jj_2_24(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_24();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(23, xla);
        }
    }

    private boolean jj_2_25(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_25();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(24, xla);
        }
    }

    private boolean jj_2_26(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_26();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(25, xla);
        }
    }

    private boolean jj_2_27(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_27();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(26, xla);
        }
    }

    private boolean jj_2_28(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_28();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(27, xla);
        }
    }

    private boolean jj_2_29(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_29();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(28, xla);
        }
    }

    private boolean jj_2_30(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_30();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(29, xla);
        }
    }

    private boolean jj_2_31(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_31();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(30, xla);
        }
    }

    private boolean jj_2_32(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_32();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(31, xla);
        }
    }

    private boolean jj_2_33(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_33();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(32, xla);
        }
    }

    private boolean jj_2_34(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_34();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(33, xla);
        }
    }

    private boolean jj_2_35(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_35();
        }
        catch (LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            jj_save(34, xla);
        }
    }

    private boolean jj_3_6()
    {
        if (jj_scan_token(QUOTEDCHAINE))
            return true;
        return false;
    }

    private boolean jj_3_27()
    {
        if (jj_scan_token(KEYLABEL))
            return true;
        if (jj_3R_3())
            return true;
        if (jj_scan_token(EQUAL))
            return true;
        if (jj_3R_2())
            return true;
        return false;
    }

    private boolean jj_3R_7()
    {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_5())
        {
            jj_scanpos = xsp;
            if (jj_3_6())
                return true;
        }
        return false;
    }

    private boolean jj_3_5()
    {
        if (jj_scan_token(CHAINE))
            return true;
        return false;
    }

    private boolean jj_3_17()
    {
        if (jj_scan_token(OPENPAR))
            return true;
        if (jj_3R_1())
            return true;
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_5())
            return true;
        if (jj_scan_token(CLOSEPAR))
            return true;
        if (jj_3R_2())
            return true;
        return false;
    }

    private boolean jj_3_10()
    {
        if (jj_scan_token(SUBSTRACT))
            return true;
        if (jj_scan_token(OPENPAR))
            return true;
        if (jj_3R_2())
            return true;
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_2())
            return true;
        if (jj_scan_token(CLOSEPAR))
            return true;
        if (jj_3R_2())
            return true;
        return false;
    }

    private boolean jj_3_4()
    {
        if (jj_scan_token(STAR))
            return true;
        return false;
    }

    private boolean jj_3_26()
    {
        if (jj_scan_token(AREA))
            return true;
        if (jj_3R_2())
            return true;
        if (jj_scan_token(HAZARDS))
            return true;
        if (jj_3R_8())
            return true;
        return false;
    }

    private boolean jj_3R_6()
    {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_3())
        {
            jj_scanpos = xsp;
            if (jj_3_4())
                return true;
        }
        return false;
    }

    private boolean jj_3_3()
    {
        if (jj_scan_token(FPNUMBER))
            return true;
        return false;
    }

    private boolean jj_3_21()
    {
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_1())
            return true;
        return false;
    }

    private boolean jj_3_16()
    {
        if (jj_scan_token(OPENPAR))
            return true;
        if (jj_3R_5())
            return true;
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_1())
            return true;
        if (jj_scan_token(CLOSEPAR))
            return true;
        if (jj_3R_2())
            return true;
        return false;
    }

    private boolean jj_3_2()
    {
        if (jj_scan_token(STAR))
            return true;
        return false;
    }

    private boolean jj_3R_2()
    {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_9())
        {
            jj_scanpos = xsp;
            if (jj_3_10())
            {
                jj_scanpos = xsp;
                if (jj_3_11())
                {
                    jj_scanpos = xsp;
                    if (jj_3_12())
                    {
                        jj_scanpos = xsp;
                        if (jj_3_13())
                        {
                            jj_scanpos = xsp;
                            if (jj_3_14())
                            {
                                jj_scanpos = xsp;
                                if (jj_3_15())
                                {
                                    jj_scanpos = xsp;
                                    if (jj_3_16())
                                    {
                                        jj_scanpos = xsp;
                                        if (jj_3_17())
                                        {
                                            jj_scanpos = xsp;
                                            if (jj_3_18())
                                            {
                                                jj_scanpos = xsp;
                                                if (jj_3R_13())
                                                    return true;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean jj_3_9()
    {
        if (jj_scan_token(SOMEOF))
            return true;
        if (jj_scan_token(OPENPAR))
            return true;
        if (jj_3R_1())
            return true;
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_2())
            return true;
        if (jj_scan_token(CLOSEPAR))
            return true;
        if (jj_3R_2())
            return true;
        return false;
    }

    private boolean jj_3R_1()
    {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_1())
        {
            jj_scanpos = xsp;
            if (jj_3_2())
                return true;
        }
        return false;
    }

    private boolean jj_3_1()
    {
        if (jj_scan_token(NUMBER))
            return true;
        return false;
    }

    private boolean jj_3_15()
    {
        if (jj_3R_4())
            return true;
        if (jj_3R_2())
            return true;
        return false;
    }

    private boolean jj_3_24()
    {
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_6())
            return true;
        return false;
    }

    private boolean jj_3R_11()
    {
        if (jj_scan_token(OPENPAR))
            return true;
        if (jj_3R_7())
            return true;
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_1())
            return true;
        if (jj_scan_token(CLOSEPAR))
            return true;
        if (jj_scan_token(OPENPAR))
            return true;
        if (jj_3R_7())
            return true;
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_1())
            return true;
        if (jj_scan_token(CLOSEPAR))
            return true;
        return false;
    }

    private boolean jj_3R_3()
    {
        if (jj_scan_token(CHAINE))
            return true;
        return false;
    }

    private boolean jj_3_14()
    {
        if (jj_scan_token(OPENPAR))
            return true;
        if (jj_3R_3())
            return true;
        if (jj_scan_token(CLOSEPAR))
            return true;
        if (jj_3R_2())
            return true;
        return false;
    }

    private boolean jj_3R_5()
    {
        if (jj_3R_1())
            return true;
        if (jj_scan_token(CARET))
            return true;
        if (jj_3R_1())
            return true;
        return false;
    }

    private boolean jj_3R_9()
    {
        if (jj_scan_token(HAZARD))
            return true;
        return false;
    }

    private boolean jj_3R_15()
    {
        return false;
    }

    private boolean jj_3R_10()
    {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_25())
        {
            jj_scanpos = xsp;
            if (jj_3R_15())
                return true;
        }
        return false;
    }

    private boolean jj_3_20()
    {
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_6())
            return true;
        return false;
    }

    private boolean jj_3_25()
    {
        if (jj_3R_9())
            return true;
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_24())
            jj_scanpos = xsp;
        if (jj_3R_10())
            return true;
        return false;
    }

    private boolean jj_3_13()
    {
        if (jj_scan_token(OPENPAR))
            return true;
        if (jj_scan_token(USEDUP))
            return true;
        if (jj_scan_token(CLOSEPAR))
            return true;
        if (jj_3R_2())
            return true;
        return false;
    }

    private boolean jj_3_19()
    {
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_6())
            return true;
        return false;
    }

    private boolean jj_3R_14()
    {
        return false;
    }

    private boolean jj_3_35()
    {
        if (jj_scan_token(0))
            return true;
        return false;
    }

    private boolean jj_3_34()
    {
        if (jj_3R_12())
            return true;
        return false;
    }

    private boolean jj_3_23()
    {
        if (jj_3R_7())
            return true;
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_20())
            jj_scanpos = xsp;
        xsp = jj_scanpos;
        if (jj_3_21())
            jj_scanpos = xsp;
        if (jj_3R_8())
            return true;
        return false;
    }

    private boolean jj_3_33()
    {
        if (jj_scan_token(EOL))
            return true;
        return false;
    }

    private boolean jj_3R_8()
    {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_22())
        {
            jj_scanpos = xsp;
            if (jj_3_23())
            {
                jj_scanpos = xsp;
                if (jj_3R_14())
                    return true;
            }
        }
        return false;
    }

    private boolean jj_3_22()
    {
        if (jj_3R_7())
            return true;
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_19())
            jj_scanpos = xsp;
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_6())
            return true;
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_6())
            return true;
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_6())
            return true;
        if (jj_3R_8())
            return true;
        return false;
    }

    private boolean jj_3_32()
    {
        if (jj_scan_token(STARTLIST))
            return true;
        if (jj_3R_2())
            return true;
        return false;
    }

    private boolean jj_3_31()
    {
        if (jj_scan_token(TOWER))
            return true;
        return false;
    }

    private boolean jj_3_8()
    {
        if (jj_scan_token(CASELABEL))
            return true;
        return false;
    }

    private boolean jj_3R_13()
    {
        return false;
    }

    private boolean jj_3_12()
    {
        if (jj_scan_token(SURROUNDINGSOF))
            return true;
        if (jj_scan_token(OPENPAR))
            return true;
        if (jj_3R_2())
            return true;
        if (jj_scan_token(CLOSEPAR))
            return true;
        if (jj_3R_2())
            return true;
        return false;
    }

    private boolean jj_3R_4()
    {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_7())
        {
            jj_scanpos = xsp;
            if (jj_3_8())
                return true;
        }
        return false;
    }

    private boolean jj_3_7()
    {
        if (jj_scan_token(OPENPAR))
            return true;
        if (jj_3R_1())
            return true;
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_1())
            return true;
        if (jj_scan_token(CLOSEPAR))
            return true;
        return false;
    }

    private boolean jj_3_30()
    {
        if (jj_scan_token(PAIR))
            return true;
        if (jj_3R_11())
            return true;
        if (jj_scan_token(HEXSIDES))
            return true;
        if (jj_3R_10())
            return true;
        return false;
    }

    private boolean jj_3_29()
    {
        if (jj_scan_token(KEYSUBTITLE))
            return true;
        if (jj_3R_7())
            return true;
        return false;
    }

    private boolean jj_3_11()
    {
        if (jj_scan_token(OPENPAR))
            return true;
        if (jj_scan_token(LEFTOVER))
            return true;
        if (jj_scan_token(CLOSEPAR))
            return true;
        if (jj_3R_2())
            return true;
        return false;
    }

    private boolean jj_3_18()
    {
        if (jj_scan_token(OPENPAR))
            return true;
        if (jj_3R_5())
            return true;
        if (jj_scan_token(COMMA))
            return true;
        if (jj_3R_5())
            return true;
        if (jj_scan_token(CLOSEPAR))
            return true;
        if (jj_3R_2())
            return true;
        return false;
    }

    private boolean jj_3_28()
    {
        if (jj_scan_token(KEYTITLE))
            return true;
        if (jj_3R_7())
            return true;
        return false;
    }

    private boolean jj_3R_12()
    {
        if (jj_scan_token(COMMENT))
            return true;
        return false;
    }

    /** Generated Token Manager. */
    public BattlelandRandomizerLoaderTokenManager token_source;
    SimpleCharStream jj_input_stream;
    /** Current token. */
    public Token token;
    /** Next token. */
    public Token jj_nt;
    private int jj_ntk;
    private Token jj_scanpos, jj_lastpos;
    private int jj_la;
    private int jj_gen;
    final private int[] jj_la1 = new int[0];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;
    static
    {
        jj_la1_init_0();
        jj_la1_init_1();
    }

    private static void jj_la1_init_0()
    {
        jj_la1_0 = new int[] {};
    }

    private static void jj_la1_init_1()
    {
        jj_la1_1 = new int[] {};
    }

    final private JJCalls[] jj_2_rtns = new JJCalls[35];
    private boolean jj_rescan = false;
    private int jj_gc = 0;

    /** Constructor with InputStream. */
    public BattlelandRandomizerLoader(java.io.InputStream stream)
    {
        this(stream, null);
    }

    /** Constructor with InputStream and supplied encoding */
    public BattlelandRandomizerLoader(java.io.InputStream stream,
        String encoding)
    {
        try
        {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        }
        catch (java.io.UnsupportedEncodingException e)
        {
            throw new RuntimeException(e);
        }
        token_source = new BattlelandRandomizerLoaderTokenManager(
            jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 0; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /** Reinitialise. */
    public void ReInit(java.io.InputStream stream)
    {
        ReInit(stream, null);
    }

    /** Reinitialise. */
    public void ReInit(java.io.InputStream stream, String encoding)
    {
        try
        {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        }
        catch (java.io.UnsupportedEncodingException e)
        {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 0; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /** Constructor. */
    public BattlelandRandomizerLoader(java.io.Reader stream)
    {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new BattlelandRandomizerLoaderTokenManager(
            jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 0; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /** Reinitialise. */
    public void ReInit(java.io.Reader stream)
    {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 0; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /** Constructor with generated Token Manager. */
    public BattlelandRandomizerLoader(BattlelandRandomizerLoaderTokenManager tm)
    {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 0; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /** Reinitialise. */
    public void ReInit(BattlelandRandomizerLoaderTokenManager tm)
    {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 0; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    private Token jj_consume_token(int kind) throws ParseException
    {
        Token oldToken;
        if ((oldToken = token).next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind)
        {
            jj_gen++;
            if (++jj_gc > 100)
            {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++)
                {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null)
                    {
                        if (c.gen < jj_gen)
                            c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    static private final class LookaheadSuccess extends java.lang.Error
    {
        // auto generated - ignore
    }

    final private LookaheadSuccess jj_ls = new LookaheadSuccess();

    private boolean jj_scan_token(int kind)
    {
        if (jj_scanpos == jj_lastpos)
        {
            jj_la--;
            if (jj_scanpos.next == null)
            {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source
                    .getNextToken();
            }
            else
            {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        }
        else
        {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan)
        {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos)
            {
                i++;
                tok = tok.next;
            }
            if (tok != null)
                jj_add_error_token(kind, i);
        }
        if (jj_scanpos.kind != kind)
            return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos)
            throw jj_ls;
        return false;
    }

    /** Get the next Token. */
    final public Token getNextToken()
    {
        if (token.next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /** Get the specific Token. */
    final public Token getToken(int index)
    {
        Token t = token;
        for (int i = 0; i < index; i++)
        {
            if (t.next != null)
                t = t.next;
            else
                t = t.next = token_source.getNextToken();
        }
        return t;
    }

    @SuppressWarnings("unused")
    private int jj_ntk()
    {
        if ((jj_nt = token.next) == null)
            jj_ntk = (token.next = token_source.getNextToken()).kind;
        else
            jj_ntk = jj_nt.kind;
        return jj_ntk;
    }

    private final List<int[]> jj_expentries = new ArrayList<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private final int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    private void jj_add_error_token(int kind, int pos)
    {
        if (pos >= 100)
            return;
        if (pos == jj_endpos + 1)
        {
            jj_lasttokens[jj_endpos++] = kind;
        }
        else if (jj_endpos != 0)
        {
            jj_expentry = new int[jj_endpos];
            for (int i = 0; i < jj_endpos; i++)
            {
                jj_expentry[i] = jj_lasttokens[i];
            }
            jj_entries_loop: for (Iterator<int[]> it = jj_expentries
                .iterator(); it.hasNext();)
            {
                int[] oldentry = (it.next());
                if (oldentry.length == jj_expentry.length)
                {
                    for (int i = 0; i < jj_expentry.length; i++)
                    {
                        if (oldentry[i] != jj_expentry[i])
                        {
                            continue jj_entries_loop;
                        }
                    }
                    jj_expentries.add(jj_expentry);
                    break jj_entries_loop;
                }
            }
            if (pos != 0)
                jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    /** Generate ParseException. */
    public ParseException generateParseException()
    {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[38];
        if (jj_kind >= 0)
        {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 0; i++)
        {
            if (jj_la1[i] == jj_gen)
            {
                for (int j = 0; j < 32; j++)
                {
                    if ((jj_la1_0[i] & (1 << j)) != 0)
                    {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0)
                    {
                        la1tokens[32 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 38; i++)
        {
            if (la1tokens[i])
            {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++)
        {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    /** Enable tracing. */
    final public void enable_tracing()
    {
        // auto generated - ignore
    }

    /** Disable tracing. */
    final public void disable_tracing()
    {
        // auto generated - ignore
    }

    private void jj_rescan_token()
    {
        jj_rescan = true;
        for (int i = 0; i < 35; i++)
        {
            try
            {
                JJCalls p = jj_2_rtns[i];
                do
                {
                    if (p.gen > jj_gen)
                    {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch (i)
                        {
                            case 0:
                                jj_3_1();
                                break;
                            case 1:
                                jj_3_2();
                                break;
                            case 2:
                                jj_3_3();
                                break;
                            case 3:
                                jj_3_4();
                                break;
                            case 4:
                                jj_3_5();
                                break;
                            case 5:
                                jj_3_6();
                                break;
                            case 6:
                                jj_3_7();
                                break;
                            case 7:
                                jj_3_8();
                                break;
                            case 8:
                                jj_3_9();
                                break;
                            case 9:
                                jj_3_10();
                                break;
                            case 10:
                                jj_3_11();
                                break;
                            case 11:
                                jj_3_12();
                                break;
                            case 12:
                                jj_3_13();
                                break;
                            case 13:
                                jj_3_14();
                                break;
                            case 14:
                                jj_3_15();
                                break;
                            case 15:
                                jj_3_16();
                                break;
                            case 16:
                                jj_3_17();
                                break;
                            case 17:
                                jj_3_18();
                                break;
                            case 18:
                                jj_3_19();
                                break;
                            case 19:
                                jj_3_20();
                                break;
                            case 20:
                                jj_3_21();
                                break;
                            case 21:
                                jj_3_22();
                                break;
                            case 22:
                                jj_3_23();
                                break;
                            case 23:
                                jj_3_24();
                                break;
                            case 24:
                                jj_3_25();
                                break;
                            case 25:
                                jj_3_26();
                                break;
                            case 26:
                                jj_3_27();
                                break;
                            case 27:
                                jj_3_28();
                                break;
                            case 28:
                                jj_3_29();
                                break;
                            case 29:
                                jj_3_30();
                                break;
                            case 30:
                                jj_3_31();
                                break;
                            case 31:
                                jj_3_32();
                                break;
                            case 32:
                                jj_3_33();
                                break;
                            case 33:
                                jj_3_34();
                                break;
                            case 34:
                                jj_3_35();
                                break;
                        }
                    }
                    p = p.next;
                }
                while (p != null);
            }
            catch (LookaheadSuccess ls)
            {
                // auto generated - ignore
            }
        }
        jj_rescan = false;
    }

    private void jj_save(int index, int xla)
    {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen)
        {
            if (p.next == null)
            {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static final class JJCalls
    {
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
